{
  "hash": "86b37e1537da99a0c641d5d4fb6e356c",
  "result": {
    "markdown": "---\ntitle: \"Homework 5: Constraint and Brokerage in the Florentine Wedding dataset\"\ndescription: |\n  Examining additional centrality measures in the Florentine network\ndate: 2022-02-16\ncategories: [r, social networks]\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"florentine\", package = \"ergm\")\nntwk_stat <- flomarriage\n\ndata(flo)\nntwk_ig <- graph_from_adjacency_matrix(flo)\n```\n:::\n\n\nBuilding on [last week's look](../697E-hw4/index.qmd) at basic network centrality attributes in the Florentine Wedding dataset, we're going to look at two new measurements of centrality: brokerage and constraints.\n\n(Note: these two concepts begin to break the \"use either one\" conclusion when choosing statnet or igraph; brokerage is a function of statnet, and constraints are a function of igraph.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nntwk_ig.nodes <- data.frame(\n    name      = V(ntwk_ig)$name,\n    totdegree = igraph::degree(ntwk_ig, loops = FALSE),\n    indegree  = igraph::degree(ntwk_ig, mode = \"in\", loops = FALSE),\n    outdegree = igraph::degree(ntwk_ig, mode = \"out\", loops = FALSE),\n    eigen     = centr_eigen(ntwk_ig, directed = T)$vector,\n    bonanich  = power_centrality(ntwk_ig),\n    centr_clo = igraph::closeness(ntwk_ig),\n    centr_btw = igraph::betweenness(ntwk_ig, directed = FALSE),\n    # igraph only\n    burt      = constraint(ntwk_ig)\n)\n# Network-level measures:\n#   closeness centralization\nntwk_ig.centr_clo = centr_clo(ntwk_ig)$centralization\n#   betweenness centralization\nntwk_ig.centr_btw = centr_betw(ntwk_ig, directed = FALSE)$centralization\n\n\nntwk_stat.nodes <- data.frame(\n    name      = ntwk_stat %v% \"vertex.names\",\n    totdegree = sna::degree(ntwk_stat),\n    indegree  = sna::degree(ntwk_stat, cmode = \"indegree\"),\n    outdegree = sna::degree(ntwk_stat, cmode = \"outdegree\"),\n    eigen     = sna::evcent(ntwk_stat, ignore.eval = TRUE),\n    bonanich  = sna::bonpow(ntwk_stat),\n    centr_clo = sna::closeness(ntwk_stat, gmode = \"graph\",\n                               cmode = \"suminvundir\"),\n    centr_btw = sna::betweenness(ntwk_stat, gmode = \"graph\")\n)\n# Network-level measures:\n#   closeness centralization\nntwk_stat.centr_clo = sna::centralization(ntwk_stat.nodes, sna::closeness, \n                                     mode = \"graph\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in geodist(dat, count.paths = FALSE, predecessors = FALSE, ignore.eval =\nignore.eval): NAs introduced by coercion\n```\n:::\n\n```{.r .cell-code}\n#   betweenness centralization\nntwk_stat.centr_btw = sna::centralization(ntwk_stat.nodes, sna::betweenness,\n                                     mode = \"graph\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in fun(dat, g = g, gmode = mode, diag = diag, ...): NAs introduced by\ncoercion\n```\n:::\n\n```{.r .cell-code}\n# Statnet-only: Gould-Fernandez Brokerage\n# temp <- data.frame(brokerage(ntwk_stat, cl = ntwk.nodes$orgtype5)$z.nli)\n# ntwk.nodes <- ntwk.nodes %>%\n#   mutate(broker.tot = temp$t,\n#          broker.coord = temp$w_I,\n#          broker.itin = temp$w_O,\n#          broker.rep = temp$b_IO,\n#          broker.gate = temp$b_OI,\n#          broker.lia = temp$b_O)\n```\n:::\n\n\n## Burt's constraint\n\n*Burt's constraint* can be thought of as a measure of a node's dependency on other nodes for connections or information. If a node has a small number of connections, or the connections are largely redundant (i.e. a small group of friends without many other connections), that node has a higher constraint than one that has connections to nodes that are less redundant to each other. It provides more pathways, or opportunities, for information or power to flow.\n\nIt should come as no surprise, given all of the various ways that the Medici are the dominant node in this dataset, that the Medici family has the lowest overall constraint. \n\nAs a reminder, here is the original network graph of the Florence wedding data with no scaling applied:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1235)\nplot(\n  ntwk_ig,\n  layout = layout_components(ntwk_ig),\n  edge.arrow.mode = 0,\n  vertex.label.color = \"black\",\n  vertex.shape = \"circle\",\n  vertex.label.font = 2,\n  main = \"Florence interfamily marriages, 1282-1500\"\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nAnd here we scale the nodes by their Burt's constraint measure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nntwk_ig_b <- ntwk_ig\nntwk_ig_b.nodes <- ntwk_ig.nodes\nntwk_ig_b.nodes$burt <- ifelse(is.na(ntwk_ig_b.nodes$burt), 1, ntwk_ig_b.nodes$burt)\n\nntwk_ig_b.nodes$burt_inv <- 5 * (1 - ntwk_ig_b.nodes$burt)\nV(ntwk_ig_b)$size <- ntwk_ig_b.nodes[,\"burt_inv\"] * 5\nV(ntwk_ig_b)$label.cex <- ntwk_ig_b.nodes[,\"burt_inv\"] / 4\nV(ntwk_ig_b)$label.cex <- pmax(V(ntwk_ig_b)$label.cex, 1)\n\n# Ensure minimum node size\nV(ntwk_ig_b)$size <- pmax(V(ntwk_ig_b)$size, 1)\n\nburts_labels <- sprintf(\"%s\\n%s\", V(ntwk_ig_b)$name,\n                            # Omit leading \"0\" can't be done in sprintf\n                            substr(as.character(round(\n                              ntwk_ig_b.nodes$burt, 3\n                            )), 2, 10))\nset.seed(1235)\nplot(\n  ntwk_ig_b,\n  layout = layout_components(ntwk_ig_b),\n  vertex.label = burts_labels,\n  edge.arrow.mode = 0,\n  vertex.label.color = \"black\",\n  vertex.shape = \"circle\",\n  vertex.label.font = 2,\n  main = \"Florence families by Burt's constraint\"\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nOnce again, we see the clear dominance of the Medici family in this measure. Note that all of the pendant nodes (Lamberteschi, Ginori, Pazzi and Acciaiuoli) have maximal constraints of 1; they are completely constrained by their single connections, by definition. The Pucci family's constraint is undefined, as it is a disconnected node.\n\nThe Medici have the lowest constraints of any family, being well-connected to other well-connected nodes with some spread among them. It is interesting to note that the Guadagni family is not far behind, though, at 0.25 to 0.21 for the Medici. They are connected to 3 well-connected nodes besides the Lamberteschi, and the Bischeri node in particular gives them indirect access to the Strozzi and Peruzzi nodes, besides the Albizzi and Tornabouni nodes that they share with the Medici. It can be seen from this that the Bischeri node is a strength for the Guadagni family in much the same way that the Barbadori node is a strength of the Medici.\n\n## Brokerage\n\nWith Gould-Fernandez Brokerage, we begin to look at the ways in which nodes mediate connections between other groups of nodes. This requires a directed network, since the direction of flow of access is a crucial aspect of the core concept. There are five roles recognized by Gould-Fernandez Brokerage:\n\nCoordinator\n: mediates contact between two individuals from his or her own group\n\nItinerant broker\n: mediates contact between two individuals from a single group to which he or she does not belong\n\nGatekeeper\n: mediates an incoming contact from an out-group member to an in-group member\n\nRepresentative\n: mediates an outgoing contact from an in-group member to an out-group member\n\nLiaison\n: mediates contact between two individuals from different groups, neither of which is the group to which he or she belongs\n\nUnfortunately for the present moment, however, we cannot apply this concept to the Florence wedding data set, because at present there are no subgroups or categories between which to identify brokers! We will need to add data to the set to find a basis for this sort of analysis, and this is where we begin to transition to a research project. \n\nI am interested in the patronage system in Renaissance Florence, particularly as it applied to artists and scientists, as a measure of influence of the families. We may be able to return to brokerage concepts once we map in data related to this concept.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}